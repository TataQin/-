# 应用接入

这一层是single-SPA:
要你的应用实现了 bootstrap 、mount 和 unmount 三个生命周期钩子，有这三个函数导出，我们的框架应用就可以知道如何加载这个子应用

当子应用第一次挂载的时候，我们会执行 bootstrap 做一些初始化，然后执行 mount 将它挂载。如果你是一个 React 技术栈的子应用，你可能就在 mount 里面写 ReactDOM.render

当你应用切换走的时候，我们会执行 unmount 把应用卸载掉，当它再次回来的时候

# App Entry

组合时机 构建时？ 运行时？
应用入口  JS? HTML?

问题一是应用的加载与切换。包括路由的处理、应用加载的处理和应用入口的选择。
问题二是应用的隔离与通信。这是应用已经加载之后面临的问题，它们包括 JS 的隔离（也就是副作用的隔离）、样式的隔离、也包括父子应用和子子应用之间的通信问题。


# 组合时机选择

在组合时机的选择上，我们有两个选择：第一个是在构建时，把主子应用打包在一起，着实际上就是一种多包的方案。这个方案它的好处是构建的时候可以做公共依赖的提取，但是它的缺点在于我们把主子应用构建方案和工具都耦合在一起了，这非常不灵活地，这样也没办法做到动态加载。所以在绝大部分情况下，我们都会选择运行时去组合，就是运行的时候才去动态的加载子应用，把它加载、渲染到框架应用里。


# 应用通信

1.Situation：事情是在什么情况下发生，基于一个怎样的背景；

运营立一个合同需要经过立项->合同->审批三个阶段，因为历史原因，每个业务都是独立的，所以有时候会有不好的用户体验，所以这三个阶段分别是在CRM、合同、审批三个系统里面完成的，每次切换系统的时候，要么会刷新页面，要么会新开窗口，会有割裂感。然后我们的主管leader就问我们能不能用种技术，把三个系统放到一个系统里面。

2.Task：你是如何明确你的任务的；

当时，我们就想到了用iframe，因为之前在其他项目有用过iframe，iframe会有布局的问题，比如必须指定高度，有时候会出现多个滚动条，还有就是路由问题，iframe和主页面是共用的浏览历史，如果从列表页跳到详情页，刷新导航会回到列表页，这会让用户非常痛苦。

因为之前我在掘金看过single-spa的相关介绍推荐，然后我就给当时前端leader推荐了这个技术，然后他就让我去调研，然后做一个简单的技术架构。

调研single-spa的时候呢，我看了一些资料也了解到它也有一些使用局限。比如它是采用js entry的方式接入微应用的，将整个微应用打包成一个js，常见的打包优化都没了，比如：按需加载、首屏资源加载优化、css独立打包等，然后它也没有做样式、js隔离，也没有做资源预加载

我当时调研了市面上的微qianduan框架，因为qiankun（实现html entry方式，优点解耦更彻底，子应用不依赖父应用独立开发）选择了qiankun

3.Action：针对这样的情况分析，你采用了什么行动方式，具体做了哪些工作内容：

为了解耦，搭建一个基座壳子出来，通过运行时动态加载子应用的这么一个方案

主要有三个核心问题要解决：
1.路由的加载和切换，这个路由劫持single-spa已经帮我们做了，qiankun会有一个全局变量来判断子应用是否在微前端框架里，只需要根据变量去重新定义路由。基座直接定义路由。当它命中子应用的路由时，会自动去加载子应用。

2.应用的通信方案
基于 props，我们把 state 和 onGlobalStateChange （就是监听函数），还有我们的 onChange （就是 setGlobalState ）三个都传给子应用。我们基于 props 也就可以实现一个简单的主子应用之间通信。

3.css隔离x f
``` css

{
loader: 'less-loader',
+ options: {
+   modifyVars: {
+     '@ant-prefix': 'yourPrefix',
+   },
+   javascriptEnabled: true,
+ },
}

``` jsx
import { ConfigProvider } from 'antd';

export const MyApp = () => (
<ConfigProvider prefixCls="yourPrefix">
<App />
</ConfigProvider>
);

```
```
4.Result：结果怎样，带来了什么价值，在整个过程中你学到了什么，有什么新的体会。

过程：
1.搭建主应用壳子
2.子应用接入
3.重新定义路由
