TCP 是一个传输层协议，提供Host-To-Host（为应用提供应用间通信的能力）数据的可靠传输，支持全双工（数据任何时候都可以双向传输），是一个连接导向的协议。

TCP/IP 5层模型
应用层
传输层
网络层（IP）
数据链路层
物理层

什么是双工/单工

在任何一个时刻，如果数据只能单向发送，就是单工
如果在某个时刻数据可以向一个方向传输，也可以向另一个方向反方向传输，而且交替进行，叫做半双工
任何时刻数据都可以双向收发，这就是全双工

URG/ACK/PSH/RST/SYN/FIN 是几个标志位，用于描述 TCP 段的行为。

以上这 5 个标志位，每个占了一个比特，可以混合使用。比如 ACK 和 SYN 同时为 1，代表同步请求和响应被合并了。

TCP协议有这样几个基本操作：
- 如果一个Host主动向另一个Host发起连接，称为SYN（Synchronization），请求同步
- 如果一个Host主动断开请求，称为FIN（Finish），请求完成
- 如果一个Host给另一个Host发送数据，称为PSH(Push)，数据推送
以上 3 种情况，接收方收到数据后，都需要给发送方一个 ACK（Acknowledgement）响应。请求/响应的模型是可靠性的要求，如果一个请求没有响应，发送方可能会认为自己需要重发这个请求。


三次握手：
1.客户端发消息给服务端（SYN） // 1次握手
2.服务端准备好进行连接
3.服务端针对客户端的SYN给一个ACK // 2次握手

你可能会问，到这里不久可以了么，2次握手就足够了，
但是服务端还没有确定客户端是否准备好了。

因此
4.服务端发送一个SYN给客户端 // 2次握手
5.客户端准备就绪
6.客户端给服务端发送一个ACK // 3次握手


四次挥手：
1.客户端需要断开链接，发送一个断开的请求，这个叫做（FIN）
2.服务端收到请求，然后给客户端一个ACK,称为FIN的响应


这时候你可能会思考一个问题，可不可以像握手那样马上传FIN回去
（服务端只能发一个回应报文ACK: "哦，我知道了"，然后通知上层传输数据的应用程序，当应用程序完成全部数据发送并告知服务器，服务器才能发送FIN报文告诉客户端可以真正断开连接了）
其实这个时候服务端不能马上传FIN，因为断开连接摇处理的问题比较多，比如说服务端可能还有发送出去的消息没有得到ACK.也有可能服务端自己有资源要释放。
所以服务端经过一个等待，确定可以关闭连接了
3.再发一条FIN给客户端
4.客户端收到服务端的FIN，同时客户端也有可能有自己的事情要处理完，比如客户端有发送给服务端没有收到ack的请求，客户端自己处理完成后，再给服务端发送一个ACK


ACK、SYN、FIN、序号、确认号
ACK、SYN、FIN只占1位（bit），而序号seq和确认号ack各占4个字节(4*8=32位)

- 报文1:[SYN=1,seq=123,ACK=0]。SYN为1表示这是询问报文，询问编号是123
- 报文2:[ACK=1,ack=124,SYN=1,seq=234]。ACK和SYN都为1表示这即是应答又是询问报文。对序号为123的报文进行应答，同时自己又询问报文，询问编号是234。
- 报文3:[ACK=1,ack=235,SYN=0].ACK位为1表示这是应答报文，对seq为234的报文进行应答

三次握手：
1.客户端发送SYN=1的询问报文给服务端，seq是n，
2.服务端回应ACK=1,SYN=1的应答+询问报文，应答号是ack=n+1.询问号是seq=m
3.客户端收到后，回应一个ACK=1的应答报文，应答号是m+1

也可以改为两次握手
1.客户端发送SYN=1的询问报文给服务端，seq是n
2.服务端收到后发送响应报文，准备接收
3.客户端收到响应后认为信道正常，开始发送

A能确认A->B是畅通的，也能确信B->A是畅通的（自己发的消息，又收到了对方的回应）。
但是B实际上只知道A->B是畅通的，并不知道B->A是否畅通。（收到了对方发的消息，但自己发的消息对方是否收到不知道），这没法称得上可靠传输

为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。