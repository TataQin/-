1.输入 URL 后解析出[协议]、[主机]、[端口]、路径等信息，并构造一个 HTTP 请求(浏览器组长一个get 请求报文)

延伸：浏览器发送请求，是否需要查看缓存？如果缓存，是否新鲜？如何检查？
2.域名解析（浏览器获取主机ip地址）

延伸：DNS递归查询可否介绍下？
3.TCP连接
为什么需要三次握手，两次不行吗？其实这是由 TCP 的自身特点可靠传输决定的。客户端和服务端要进行可靠传输，那么就需要确认双方的接收和发送能力。第一次握手可以确认客服端的发送能力，第二次握手，确认了服务端的发送能力和接收能力，所以第三次握手才可以确认客户端的接收能力。不然容易出现丢包的现象。

4.http 请求
5.服务器处理请求并返回 HTTP 报文（通过tcp链接）

6.浏览器渲染页面
延伸：
解析的时候，具体如何解析，是否有顺序？
渲染过程如下：
- 解析HTML,构建DOM树。
- 解析CSS,生成CSS规则树
- 合并DOM树和CSS规则，生成render树
- 布局render树（Layout/reflow），负责各元素尺寸、位置的计算
- 绘制render树（paint）,绘制页面像素信息
- 浏览器会将各层的信息发送给GPU,GPU会将各层合成，显示在屏幕上

7.断开TCP连接
延伸：
关闭tcp的四次挥手是什么？

延伸：
URL请求过程：
浏览器进程会通过进程间通信（IPC）把URL请求发送至网络进程，网络进程接收到URL请求后，会开始构建请求->查找缓存->DNS查询 


1.浏览器进程接收到用户输入的url请求，浏览器进程便将该 URL 转发给网络进程
2.在网络进程发送真正的url请求
3.准备渲染进程
4.提交文档：浏览器进程将网络进程接收到的 HTML 数据提交给渲染进程

5.渲染阶段：
5-1.构建dom树
5-2.样式计算

把 CSS 转换为浏览器能够理解的结构
- 通过link引入的外部css文件
- <style>标签内的样式
- 元素的style属性内嵌的css
1.将上述三种 CSS 文本转换为浏览器可以理解的结构——styleSheets。
2.转换样式表中的属性值，使其标准化
3.利用 CSS 的继承规则和层叠规则进行计算标签的具体样式

5.3.布局阶段
构建布局树
- 遍历 DOM 树中的所有可见节点，并把这些节点加到布局树中；
- 而不可见的节点会被布局树忽略掉

布局计算：
DOM & CSSOM 合并成渲染树

5.4分层
现在我们有了布局树，而且每个元素的具体位置信息都计算出来了，那么接下来是不是就要开始着手绘制页面了？答案依然是否定的。
因为页面中有很多复杂的效果，如一些复杂的 3D 变换、页面滚动，或者使用 z-index 做 z 轴排序等，为了更加方便地实现这些效果，渲染引擎还需要为特定的节点生成专用的图层，并生成一棵对应的图层树（LayerTree）。
浏览器的页面实际上被分成了很多图层，这些图层叠加后合成了最终的页面。

5.5 图层绘制
5.6 栅格化（raster）操作
5.7 合成和显示